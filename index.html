<!DOCTYPE html>
<html>
  <head>
    <title>Creating &amp; Designing Objects in Modern JS</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="styles.css">
  </head>
  <body>
    <textarea id="source">

class: center, middle
# Creating &amp; Designing Objects in Modern JS
**By Will Hastings**

Follow along: [go/creating_designing_objects_js][slides]

[slides]: http://go/creating_designing_objects_js

???

* Me: Web Dev, Horizontal
* Talk about:
  * What concerns rely on how we create and design objects
  * What patterns exist for creating objects and accomplishing inheritance
  * How can we work w/ JS to create robust OO architectures?
  * What implementations are out there?

---

class: center, middle
# Concerns

???

* What do we care about when choosing how to create and design objects?
* Goals?
* Important to recognize these first before choosing

---

class: slide-short
# Architectural Flexibility

* Avoid deep, inflexible inheritance hierarchies
* Keep code modular, decoupled
* Respect Open/Closed Principle

???

* Want to avoid rigid relationships between types.
* Want to avoid *tight coupling* between types and between instances.
* Want types/modules *open for extension*, but *closed for modification*
* Terminology: Types instead of classes

---

class: slide-short
# Robust APIs and Encapsulation

* Clear public interface
* Ability to write small, composable types/modules that *do one thing*
* Hidden implementation details

???

* Want our public methods to be clear/descriptive
* Want API easy to use
* Want composing code to be easy
  * Maintable code = small, decoupled modules composed together to create more complex functionality
* Want our implementation details hidden so user isn't concerned w/ them
  * Or tempted to mess w/ them

---

# Ease of Use

* Want a pattern or API that is concise and easy to use.
* i.e. not this:

```javascript
var Dialog = ...;

var Modal = function(title, body) {
  this.title = title;
  this.body = body;
};

Modal.prototype = Object.create(Dialog.prototype);

Modal.prototype.open = function() {
  // ...
};

Modal.prototype.close = function() {
  // ...
};
```

???

* Terse
* Low overhead
* Simple

---

# Performance

* We don't want it to suffer.
* But we don't want to sacrifice power for premature optimizations
* Consider alternatives before restricting your object-creation strategy
  (e.g. [object pools][pools]).

>*...if you're only creating a few objects (and by that, I mean 100 or less),
the performance of creating them is basically irrelevant.  If you’ve been led
to believe you need to use prototype, new, and class style coding in JS to get
maximum object creation performance for just a couple of objects, you need to
set such silliness aside.* -- Kyle Simpson, [Sanity Check: Object Creation
Performance](http://blog.getify.com/sanity-check-object-creation-performance/)

[pools]: http://beej.us/blog/data/object-pool/

???

* Won't focus on this too much
* Other goals vs. performance
* My take:
  * Choose pattern that helps you write best code
  * If usage/profiling shows real perf problem
    * Try alternative techniques
    * Change only objects that need max perf
* Quote: People get hung up on benchmarks (JSPerf)
  * Really, difference may only be nanoseconds

---

class: center, middle

# Creation and Design Patterns

???

* Look at some patterns and discuss their pros and cons regarding our concerns

---

# Prototypal Inheritance

* Usually used in manner following classical inheritance
* But there are other patterns that prototypes enable
  * e.g. [**OLOO**][oloo] (Objects Linked to Other Objects)
* Implemented via constructors or `Object.create()`
* Some argue [it's behavior delegation, not inheritance][js_obj_article].

[oloo]: https://github.com/getify/You-Dont-Know-JS/blob/master/this%20&amp;%20object%20prototypes/ch6.md
[js_obj_article]: http://davidwalsh.name/javascript-objects

???

* Classical: Create instances from a prototype
* OLOO
  * Coined by Kyle Simpson
  * Says objects aren't parent and children but peers
  * They delegate amongst themselves using the prototype mechanism
  * You should check it out
* Behavior Delegation: Inheritance is copying from parent to child, and
  delegation is the reverse
  * Plays in to OLOO
  * My opinion: Still works for types/instances

---

# Prototypal Inheritance
## Constructors

.col-half[
```javascript
var Dialog = function(title, body) {
  this.title = title;
  this.body = body;
};

Dialog.prototype.close = function() {
  // ...
};

Dialog.prototype.open = function() {
  // ...
};

var dialog = new Dialog(
  'Profile',
  renderedTemplate
);
```
]

.col-half[
* Require use of `new` or internal check.
* Add extra step to reach prototype object (`.prototype`).
* Encourage dev to think in classical mindset.
* Obscure prototypal mechanism that JS actually uses.
* Verbose.
* That said, are usually best optimized (e.g. [V8 hidden classes][v8])
]

[v8]: http://mrale.ph/blog/2014/07/30/constructor-vs-objectcreate.html

???

* All honesty: I don't like constructors
* They are the traditional way of creating types
* If you forget `new` and not in strict mode, instance props go on `window`
* Constructors make themselves look more important that prototypes
  * But prototypes are what matter after an object is created
* Prefer to work directly with prototype objects
* Perf tests will show they're fastest
  * But does that matter?

---

# Prototypal Inheritance
## Constructors: Inheritance

.col-two-third[
```javascript
function inherit(child, parent) {
  function Surrogate() {}
  Surrogate.prototype = parent.prototype;
  child.prototype = new Surrogate();
  child.prototype.constructor = parent;
}

var SlidingDialog = function(title, body) {
  Dialog.call(this, title, body);
  // ...
};

inherit(SlidingDialog, Dialog);
// OR: SlidingDialog.prototype =
//     Object.create(Dialog.prototype);

SlidingDialog.prototype.open = function() {
  Dialog.prototype.open.call(this);
  // ...
};
```
]

.col-one-third[
* Too manual.
* Mimicks classical inheritance.
* Calling super is ugly and unwieldy.
]

???

* `inherit()` is way to set up inheritance in ES before 5
* Can use `Object.create()` in ES5+

---

# Prototypal Inheritance
## Constructors

*The real problem is that using constructors will almost always get you stuck
thinking in classical OO mode. The constructor becomes analogous to a class.* --
Eric Elliott, [Programming JavaScript Applications][pja]

*Constructors violate the open/closed principle because they couple all callers
to the details of how your object gets instantiated.* -- Eric Elliott, [The Two
Pillars of JavaScript, Part 1][two_pillars]

*JavaScript doesn’t need constructor functions because any function can return a
new object. With dynamic object extension, object literals and
`Object.create()`, we have everything we need — with none of the mess.* -- Eric
Elliott, [The Two Pillars of JavaScript, Part 1][two_pillars]

*it's only objects, linked to other objects. That's really all JS has.* -- Kyle
Simpson, [JS Objects: De"construct"ion][deconstruction]

[pja]: http://shop.oreilly.com/product/0636920033141.do
[two_pillars]: https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3
[deconstruction]: http://davidwalsh.name/javascript-objects-deconstruction

???

* Constructors added to JS to resemble classical languages
* Eric Elliott, Interesting argument: Constructors force caller to use `new`
  * Can't refactor easily
* Also argues: Constructors are superfluous because any function can return new
  object
* Kyle Simpson sums up JS's true nature: Objects linked to objects
  * Also, to great graphs: constructors vs. `Object.create()`

---

# Prototypal Inheritance
## `Object.create()`

* Work directly with prototype objects.
* Cooperate with JS's prototypal nature.
* Create object with prototype as any other object.
* Initialization can be captured in method on prototype.
* Can wrap `Object.create()` and init call in a factory function.

```javascript
var Dialog = {
  init: function(title, body) {
    this.title = title;
    // ...
  },
  open: function() {
    // ...
  }
};
var createDialog = function(body, title) {
  var dialog = Object.create(Dialog);
  dialog.init(body, title);
  return dialog;
}
```

???

* Work with prototypes: pass one in, get instance back out
* Reveals how JS's prototypal mechanism instead of hiding it
* Flexible: Any object can be a prototype
* Can add regular method to do work of constructor `init()`
* Can wrap instantiation details in factory function
  * Could be creating new object, or using a pool, etc.
* Factory doesn't need `new`

---

# Prototypal Inheritance
## `Object.create()` Inheritance

```javascript
var SlidingDialog = Object.create(Dialog);

SlidingDialog.init = function(title, body) {
  Dialog.init.call(this, title, body);
};

SlidingDialog.open = function() {
  Dialog.open.call(this);
  // ...
};

SlidingDialog.close = function() {
  // ...
};
```

???

* Simpler and more concise than constructor inheritance
* Still some boilerplate
* Super-style calls aren't that much better

---

# Concatenative Inheritance

* Extending type or instance with properties from multiple source types or objects.
* a.k.a. Mixins
* Composing new types from existing ones
* Avoids perils of classical, single-inheritance hierarchies
* Takes advantage of JS's *dynamic runtime object extension*
* Gives power of another full language feature like Ruby's modules or Scala's traits
* Just needs a simple function like `_.extend()`
* Can be combined with prototypal inheritance.

>*Single-­parent hierarchies are rarely capable of describing all possible use
cases. Eventually, all hierarchies are "wrong" for new uses &mdash; a problem that
necessitates code duplication.* -- Eric Elliott, [Programming JavaScript
Applications][pja]

???

* Fancy term for what we know of as mixins
* Copy props from one more more objects to another
* Because JS has dynamic object extension (define), you can use a pattern
  that is a whole feature in other languages
* Works hand-in-hand with prototypal inheritance
* Quote: Single inheritance is too rigid
  * Sometimes, you have set of concerns that applies horizontally across
    multiple types

---

# Concatenative Inheritance

## Example

.container.code[
.col-half[
```javascript
var Commentable = {
  addComment: function(comment) {
    // ...
  },
  numComments: function() {
    // ...
  }
};

var Likeable = {
  isLiked: function() {
    // ...
  },
  like: function() {
    // ...
  }
};
```
]

.col-half[
```javascript
var Post = {
  init: function(title, body) {
    // ...
  },
  save: function() {
    // ...
  }
  // ...
}

_.extend(Post, Commentable, Likeable);
```
]
]

???

* Two horizontal concerns:
  * Many types can be Commentable
  * Many types can be Likeable
* When working directly w/ prototypes, easy to mix in

---

class: slide-short
# Encapsulation Patterns

* Keep public API clean.
* Hide implementation details.
* Encourage intended use.

???

* How do we hide internals implementation details and keep public API clean?
* How to deal w/ JS's lack of private properties and methods
* Having private state and methods visible makes objects harder to use
  * e.g. property list in debugger

---

# Encapsulation Patterns
## Underscore Convention

.col-half[
```javascript
Dialog = {
  // ...
  open: function() {
    this._animate();
    // ...
  },
  // ...
  _animate: function() {
    // ...
  }
};
```
]

.col-half[
* Have to remember to prefix all private method names w/ underscore
* Not true encapsulation, just a convention
* Arguably unattractive
]

???

* Just a convention, no real language semantics
* Dev has to remember
* Personally, find it ugly

---

# Encapsulation Patterns
## Closure-Based

.col-half[
```javascript
function createDialog(title, body) {
  var open = false;

  function init() {
    // ...
  }

  function animate() {
    // ...
  }

  function open() {
    open = true;
    // ...
  }

  // ...

  init();

  // Public API:
  return {
    close: close,
    open: open
  };
};
```
]

.col-half[
* Bestows true privacy to state and implementation methods
* Object only exists to hold public methods
* But hard to distinguish free variables from local variables
* How to use with inheritance and mixins?
]

???

* Tends to be most common way of implementing privacy and encapsulation
* Use closure to hide private state variables and private functions
* Return object with only public methods
* Issues:
  * Free variables hard to distinguish
  * Unclear how inheritance or mixins would work

---

# Encapsulation Patterns
## Closured-Methods Only

.col-half[
```javascript
window.Dialog = (function() {
  var Dialog = {
    init: function(el) {
      this.el = el;
      // ...
    },
    // ...
    open: function() {
      // Invoke with current context.
      animate.call(this);
    },
    // ...
  };

  /*** Private Methods: ***/

  function animate() {
    var el = this.el;
    // ...
  }

  return Dialog;
}());
```
]

.col-half[
* Gives truly private methods
* But doesn't protect state
* Requires remembering to use `call()` for private methods.
]

???

* An approach I've been favoring recently
* Only protects methods, giving clean API
* Having to add `.call(this)` for each private function is annoying

---

class: center, middle

# Implementations

???

* End by looking at implementations out there and what concerns they address

---

# Resig Inheritance

**[ejohn.org/blog/simple-javascript-inheritance][resig]**

```javascript
var Dialog = Class.extend({
  init: function(el) {
    this.el = el;
    // ...
  },
  open: function() {
    this.open = true;
    // ...
  }
});

var SlidingDialog = Dialog.extend({
  init: function(el) {
    this._super(el);
  },
  open: function() {
    this._super();
    this._animate();
  },
  _animate: function() {
    // ...
  }
});

var slidingDialog = new SlidingDialog(
  document.querySelector('#dialog-el')
);
```

[resig]: http://ejohn.org/blog/simple-javascript-inheritance/

???

* Class utility w/ extend method
* Adds `extend()` to each "class" created so they can be further extended
* Provides nifty `_super()` method for calling same method further up
  inheritance chain

---

# Resig Inheritance

.col-half[
## Pros
* Easy `super` calls
* Easy "subclassing" with `.extends()`
]

.col-half[
## Cons
* Very classically-oriented
* Instantiating requires `new`
* No real state or method privacy
* No built-in support for Concatenative Inheritance
]

???

* Good pioneer for creation/inheritance implementation
* Easy super and `extends()`
* Dated: Posted in 2008
* Very seated in classical OO mindset
* Need `new`
* No mixins

---

# Fiber

**[github.com/linkedin/Fiber][fiber]**

.container.code[
.col-half[
```javascript
var Dialog = Fiber.extend(function() {
  return {
    init: function(el) {
      this._el = el;
      this._open = false;
    },
    close: function() {
      this._open = false;
      // ...
    },
    open: function() {
      this._open = true;
      // ...
    }
  };
});
```
]

.col-half[
```javascript
var SlidingDialog = Dialog.extend(
  function(base) {
  return {
    init: function(el, slideClass) {
      // Base refers to
      // Dialog's prototype.
      base.init.call(this, el);
      this._slideClass = slideClass;
    },
    open: function() {
      base.open.call(this);
      this._animate();
    },
    _animate: function() {
      // ...
    }
  };
});

var slidingDialog = new SlidingDialog(
  document.querySelector('#dialog-el'),
  'slide-down'
);
```
]
]

[fiber]: https://github.com/linkedin/Fiber

???

* `Fiber.extend()` takes function to return prototype properties
* Adds `extend()` to type to created derived types
* Passes `base` in for easy super access

---

# Fiber

.col-half[
## Pros
* Easy access to "superclass" through `base` argument
* Supports Concatenative Inheritance through mixins and decorators
]

.col-half[
## Cons
* Constructors require `new`
* No built-in mechanism for private state and methods
]

???

* Has mixins and decorators
* But no privacy

---

# ES6 Classes

**[2ality.com/2015/02/es6-classes-final.html][es6classes]**

.container.code[
.col-half[
```javascript
class Dialog {
  constructor(el) {
    this.el = el;
    this.open = false;
  }
  close() {
    this.open = false;
    // ...
  }
  open() {
    this.open = true;
    // ...
  }
}
```
]

.col-half[
```javascript
class SlidingDialog extends Dialog {
  constructor(el, slideClass) {
    super(el);
    this._slideClass = slideClass;
  }
  // ...
  open() {
    super.open();
    this._animate();
  }
  _animate() {
    // ...
  }
}

var slidingDialog = new SlidingDialog(
  document.querySelector('#dialog-el'),
  'slide-down'
);
```
]
]

[es6classes]: http://www.2ality.com/2015/02/es6-classes-final.html

???

* Have as implementation, but keep in mind it's now a standard
* New keywords (`class`, `extends`, `super`)
* Initialization done in special constructor method
* Can call "superclass" constructor w/ `super()`
* Can call method of "superclass" w/ `super.method()`

---

# ES6 Classes

.col-half[
## Pros
* Terse, easy-to-use syntax
* Familiar to new JS devs
* Native subclassing capability
* Native, concise super calls
* Can subclass built-in types
]

.col-half[
## Cons
* Not true classes, but syntactic sugar over constructors and prototypes.
* Not yet [well-supported](http://kangax.github.io/compat-table/es6/#class)
* Some features hard to transpile (e.g. super calls, extending built-ins)
* No mechanism for making state or methods private
* Constructors require `new`
]

???

* Nice syntax
* Looks familiar to devs coming from classical languages like Java
* Adds native support for features that were previously hand-implemented
* Easy super calls
* But not real classes
* Hard to use now because of lack of native support and transpile-able features
* No privacy

---

# Stampit

**[github.com/ericelliott/stampit][stampit]**

```javascript
var dialog = stampit()
  .state({
    el: null,
    title: 'Dialog' // Default value.
  })
  .methods({
    setTitle: function(title) {
      this.title = title;
    }
  })
  .enclose(function() {
    var open = false;

    return stampit.mixIn(this, {
      close: function() {
        open = false;
      },
      isOpen: function() {
        return open;
      },
      open: function() {
        open = true;
        // ...
      }
    })
  });
```

[stampit]: https://github.com/ericelliott/stampit

???

* Stamps are factory functions created from `stampit()` invocation
* Public methods attached to prototype (`.methods()`)
* State w/ default values copied in on instantiation (`.state()`)
* Private state and methods achieved through closures with *privileged methods*
  attached to instance

---

# Stampit

.col-half[
## Pros
* Supports [concatenative, prototypal, and functional inheritance][three_kinds_oo]
* Produces factory functions (no need for `new`)
* Can compose stamps together with `stampit.compose()`
]

.col-half[
## Cons
* Unorthodox API
* Steeper learning curve
]

[three_kinds_oo]: http://ericleads.com/2013/02/fluent-javascript-three-different-kinds-of-prototypal-oo/

???

* Supports three types of inheritance
  * Functional inheritance: Not real inheritance, but does allow for
    encapsulation
* Great library, but harder to learn
---

# Protomatter.js

**[github.com/whastings/protomatter.js][protomatter]**

[protomatter]: https://github.com/whastings/protomatter.js

.container.code[
.col-half[
```javascript
var Dialog = Protomatter.create({
  init: function(el) {
    // Who needs underscores?
    this.el = el;
    this.open = false;
  },
  close: function() {
    this.open = false;
    // ...
  },
  open: function() {
    this.open = true;
    // ...
  }
});
```
]

.col-half[
```javascript
var SlidingDialog = Protomatter.create({
  init: function(el, slideClass) {
    this.callSuper('init', el);
    this.slideClass = slideClass;
  },
  // ...
  open: function() {
    this.callSuper('open');
    this.animate();
  },
  // Private methods:
  private: {
    animate: function() {
      // ...
    }
  }
});
```
]
]

.pre-no-margin[
```javascript
var slidingDialog = SlidingDialog.create(
  document.querySelector('#dialog-el'),
  'slide-down'
);
console.log(slidingDialog.el); // undefined
console.log(slidingDialog.open); // undefined
console.log(slidingDialog.slideClass); // undefined
```
]

???

* `Protomatter.create()` takes props and returns new prototype object
* Prototype has `create()` method for producing instances
* Prototype has `extend()` for creating new prototypes in the chain
* Has `callSuper()` as a moderately easy/elegant way of invoking method from prototype
  higher in the chain
* You've noticed how I keep mentioning lack of privacy:
  * Is protomatter's selling point
  * Any property added to `this` is inaccessible from outside own methods
  * Methods placed under `private` are inaccessible from outside own methods
  * Magic: Two objects created
    * One w/ public methods, returned to the outside
    * One w/ private state props and methods

---

# Protomatter.js

.col-half[
## Pros
* Truly private properties and methods
* Concatenative Inheritance support via `Protomatter.compose()`
* Easy super calls
]

.col-half[
## Cons
* [Privacy magic][protomatter_privacy] increases runtime complexity
* Possible performance hit
]

[protomatter_privacy]: http://objectdotcreate.net/implementing-object-privacy-protomatter-js.html

???

* This project represents my ideal way of doing OO in JS
* Get true privacy w/o downsides of manual closures
* But privacy magic adds complexity (e.g. wrapper functions in call stack)
* Haven't run perf tests yet, but definitely will be on the slow side
  * Again, how much does that matter

---

# Resources

## Libraries

* [Stampit][stampit]
* [Fiber][fiber]
* [Protomatter.js][protomatter]

## Articles

* [Simple JavaScript Inheritance (Resig Inheritance)](http://ejohn.org/blog/simple-javascript-inheritance/)
* [Sanity Check: Object Creation Performance](http://blog.getify.com/sanity-check-object-creation-performance/)
* [Three Different Kinds Of Prototypal OO][three_kinds_oo]
* [JS Objects: De"construct"ion](http://davidwalsh.name/javascript-objects-deconstruction)
* [The Two Pillars of JavaScript, Part 1](https://medium.com/javascript-scene/the-two-pillars-of-javascript-ee6f3281e7f3)
* [Implementing Object Privacy in Protomatter.js][protomatter_privacy]

    </textarea>
    <script src="remark.min.js"></script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
